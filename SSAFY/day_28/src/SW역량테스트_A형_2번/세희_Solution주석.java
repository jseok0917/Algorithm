package SW역량테스트_A형_2번;

import java.util.Scanner;

public class 세희_Solution주석 {
	// 문제 정보
	// N x N : 맵의 크기(가로, 세로 동일)
	// (1,1)에서 출발하여 (N,N)지점으로 최소한의 연료를 사용하여 도착하려고 한다.
	// 높은 위치에서 낮은 위치로 갈 때는 연료 0 소모
	// 같은 위치에서 이동할 때는 연료 1 소모
	// 낮은 위치에서 높은 위치로 이동할 때는 위치차이*2 소모
	// 입력값으로 N과 맵 정보가 주어진다. 맵 정보는 땅의 높이를 의미한다.
	
	static int N;
	static int[][] map;
	
	//최소연료를 계산할 변수
	static int min;
	//방문체크
	static boolean[][] visited;
	//델타 탐색
	static int[] dr = {-1, 1, 0, 0};
	static int[] dc = {0, 0, -1, 1};
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		//맵의 크기 입력
		N = sc.nextInt();
		
		//맵 정보 초기화
		map = new int[N][N];
		
		//맵 정보 입력
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				map[i][j] = sc.nextInt();
			}
		}
		
		//최솟값 초기화 및 기본값 입력
		min = Integer.MAX_VALUE;
		
		//방문 배열 초기화
		visited = new boolean[N][N];
		
		//출발점은 방문처리를 하고 넘어간다.
		visited[0][0] = true;
		
		//시작점 (0,0), 처음엔 사용한 연료가 없으니까 0
		bruteForce(0, 0, 0);
		
		System.out.println(min);
		
		
	}
	
	//모든 경로를 완전 탐색하여 확인한다.
	
	//현재 행 위치 : r
	//현재 열 위치 : c
	//지금까지 사용한 연료양 : used
	static void bruteForce(int r, int c, int used) {
		
		//재귀 종료 조건 : 도착지점에 도달했을 경우
		if (r == N-1 && c == N-1) {
			//사용 연료가 현재까지의 최솟값보다 작으면 
			//최솟값을 갱신하고 종료
			if (used < min) {
				min = used;
			}
			
			return;
		}
		
		//문제를 재귀적으로 푼다는 건,
		//문제를 귀납적으로 푼다는 뜻이다.
		//귀납적으로 문제를 푼다는 건,
		
		//우리가 임의의 N번째 단계에서 취할 수 있는 "모든" 케이스를 고려하여
		//각각의 케이스에서 취해야하는 행동을 지시해주고
		//다음 N+1번째 단계로 나아간다는 것이다.
		
		//그러면 우리는 임의의 과정에서 발생할 수 있는
		//모든 것들을 지시했기 때문에, N+1단계의 과정이 오더라도
		//우리가 지시한 행동강령에 따라 해당 과정을 문제없이 진행할 것이다.
		//따라서 모든 과정을 오류없이 밟아나가면서 완전탐색이 가능하다.
		
		
		//즉, 우리가 재귀함수를 사용하는 코드를 구현할 때는
		//재귀를 진행하는 임의의 단계에서
		//1번. 각각의 케이스에서 취할 수 있는 "모든 행동"을 코드로 작성하는 것이 기본이고,(완전탐색 할거니까)
		//2번. 각각의 행동에 대하여 "어떤 상황이 발생할 수 있는지"를 "모두 고려"하여 코드로 작성해야 한다.
		
		//지금 이 문제의 경우에는 어떤 임의의 지점에서 가능한 행동은
		//상, 하, 좌, 우 네 방향으로 움직이는 것이고,
		//실제로 완전탐색을 하려면 네 방향으로 모두 움직여보아서 (1번 : 취할 수 있는 모든 행동을 코드로 작성한다.)
		//각각의 케이스에 필요한 연료를 계산하여 다음 과정으로 넘겨주면 된다.
		//따라서 다음과 같이 코드를 작성한다.
		
		//델타탐색(이게 임의의 과정에서 가능한 행동의 전부다)
		for (int i = 0; i < 4; i++) {
			int nr = r + dr[i];
			int nc = c + dc[i];
			
			//다음에 갈 곳이 map 밖이라면 움직일 필요조차 없기 때문에(2번 : 가능한 모든 케이스를 고려)
			//skip해야한다. 
			if (nr < 0 || nr >= N || nc < 0 || nc >= N) {
				continue;
			}
			
			//다음에 갈 곳이 이미 방문한 곳이라면?
			if (visited[nr][nc]) {
				//스킵해야한다.
				continue;
			}
			//이미 방문한 곳을 재방문할 경우
			//최소연료로 도착지점에 도달하는 것이 무조건 불가능하다.
			
			//예를 들어 출발지점 A에서 도착지점 D에 도달하려고 한다고 하자.
			//그리고 B지점을 통하면 D에 도달할 수 있는데, B를 재방문했다고 생각하면
			//중간에 어떤 지점 C를 거쳐서 B로 되돌아왔을 것이고 경로는 다음과 같을 것이다
			//A -> B -> C -> B -> D 
			//B를 방문하고 다시 B로 돌아오는 과정이 생기게 되는데, 애초에 B에서 도착지점 D로
			//이동한 것이 가능한 상황이면, B를 재방문하는 과정 자체를 SKIP하는
			//A -> B -> D 경로가 연료를 덜 소모할 수 밖에 없다.
			//따라서, 다음에 움직일 곳이 방문한 곳이라면 스킵해야한다.
			//또한, 방문한 곳을 또 방문할 수 있다면 무한재귀가 돌게된다. (2번 : 가능한 모든 케이스를 고려)
			
			
			//여기까지 넘어오면 다음에 갈 곳은 방문하지 않은 곳이므로
			//방문은 확정이다.
			//따라서 이제 방문처리를 해준다.
			visited[nr][nc] = true;
			
			
			
			//다음 지점으로 가기위한 연료는 다음 지점의 땅의 높이,
			//map[nr][nc]에 의존하므로
			//현재 높이 map[r][c]와
			//다음 높이 map[nr][nc]를 고려하여 필요한 연료를 계산한다. (2번 : 가능한 모든 케이스를 고려)
			//이 연료 계산 방식은 문제에 의거하여 정확히 3가지가 존재한다.
			int fuel = 0;
			if (map[r][c] > map[nr][nc]) {
				//낮은 위치로 가는거면 필요연료X
				fuel = 0;
			} else if (map[r][c] == map[nr][nc]) {
				//같은 위치로 가는거면 연료 1 소모
				fuel = 1;
				
			//else로 써도 되지만 가독성을 위해 3번째도 else if로 작성
			} else if (map[r][c] < map[nr][nc]) {
				//높은 위치로 가는거면 높이차*2 연료소모
				fuel = 2*(map[nr][nc] - map[r][c]);
			}
			
			//나올 수 있는 연료 계산을 경우를 모두 고려하였으므로,
			//다음 경로로 진행하면 된다.
			//used : 현재까지 사용한 연료양이고,
			//다음 경로로 가는데 fuel만큼 연료 소모하니까
			//used+fuel을 넘기면 된다.
			bruteForce(nr, nc, used+fuel);
			
			//이렇게 코드를 짜면
			//일단 갈 수 있는 곳을 쭉 다 가본 다음에
			//왜냐하면 bruteForce메서드에서 bruteForce를 호출하고, 
			//가능한 모든 호출이 모두 이루어질 때까지 스택이 쌓이기 때문이다.
			//이러한 스택이 역으로 실행되며 모두 실행완료된 후에야
			//재귀함수가 종료되며 다음 코드 (여기서는 for문(델타탐색))가 진행될 수가 있다.
			
			//이 코드로 넘어왔다는 건
			//(nr, nc)을 거쳐서 가는 모든 경로 탐색을 마쳤다는 것이고,
			//다시 현재지점 (r, c)로 돌아왔다는 것이다.
			
			//그리고 이제 다른 방향의 경로를 탐색해야하는데, 현재 지점 (r,c)로 돌아왔으니
			//nr, nc는 방문하지 않은 셈이 되는 것이기 때문에 방문처리를 되돌려준다.
			visited[nr][nc] = false;
			
		}
		
		
		
		
		
	}
	
	
	
	

}
